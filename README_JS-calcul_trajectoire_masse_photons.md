# README associ√© au fichier JS-calcul_trajectoire_masse_photons.js

Etant donn√© l'impossibilit√© de mettre des commentaires dans les fichiers de code JavaScript d√ª √† un soucis d'optimisation du code nous avons d√©cid√© de cr√©er des fichiers en markdown pour chaque fichier JavaScript. Le code sera ainsi bien plus ais√© √† comprendre pour nos successeurs. 

‚ö†Ô∏è Si vous apportez des modifications au code associ√© √† ce README veuillez modifier ce README pour les ann√©es suivantes. 

üìç Ce README est associ√© au fichier JS-calcul_trajectoire_masse_photons.js lui m√™me associ√© √† la page "Masse baryonique et photon" de la partie Trajectoires.

Nous suivrons la syntaxe du code pour pouvoir l'expliquer. Etant donn√©s que la promotion qui a √©crit ce README (2024) n'est pas celle ayant cr√©√© la majorit√© de ces fonctions nous n'en garantissons pas ni la logique ni la fonctionnalit√©. Ce README est simplement une tentative d'explication de ce qui a √©t√© fait pr√©c√©demment. 

## Variables globales

La premi√®re chose qui est faites dans ce code est de d√©clarer les variables globales. Voici √† quoi nous avons compris qu'elles √©taient associ√©es :

**DIAMETRE_PART** = semble correspondre au diam√®tre des particules. 
**z** = üöß *pas utilis√©e du tout dans le programme*.
**z_obs** = üöß *pas utilis√©e du tout dans le programme*.
**title** = variable pour les textes de titre. 
**clicks** = üöß *pas utilis√©e du tout dans le programme*.
**nzoom** = variable pour la valeur du zoom. 
**facteurDeMalheur** = liste de facteurs d'√©chelle de l'animation pour les diff√©rents mobiles.
**fact_defaut** = facteur d'√©chelle de l'animation.
**factGlobalAvecClef** = facteur d'√©chelle de l'animation.
**compteurVitesseAvantLancement** = valeur qui comptabiliser le nombre de fois o√π on appuyer sur acc√©l√©rer et ralentir.

## Variables globales, key values

**rmaxjson** = initialis√©e vide. 
**mobilefactor** = facteurs de mise √† l'√©chelle.
**r0o2** = liste des distances initiales des projectiles au centre de l'astre. Initialis√©e vide.
**maximum** = valeur de la distance initiale d'un projectile au centre de l'astre qui est la plus grande compar√©e aux autres projectiles.
**cle** = utilis√© plusieurs fois au cours du programme pour stocker des indices de liste ou autres indices.
**fuseecompteur** = nombre de projectiles choisi par l'utilisateur.
**listejsonfusees** = r√©sultats de la fonction **initialisation** pour chaque fus√©e. Initialis√©e vide.

## Liste de couleur en hexa

Fixe des couleurs dans des constantes √† l'aide des couleurs hexad√©cimales. Les couleurs hexad√©cimales sont compos√©es de 6 chiffres hexad√©cimaux qui repr√©sent les intensit√©s des composantes rouge, verte et bleue de la couleur. Chaque paire de chiffres hexad√©cimaux repr√©sente une valeur de 0 √† 255 pour chaque composante, allant de l'absence de couleur (0) √† sa pleine intensit√© (255).
Ainsi pour le rouge pur on a le code hexad√©cimal #FF0000 et pour le vert pur on a #00FF00.

Dans le code sont ainsi cod√©es 9 couleurs : **COULEUR_NOIR** (#2F2D2B), **COULEUR_BLEU** (#4080A4), **COULEUR_CYAN** (#008B8B), **COULEUR_BLANC** (#FFFFFF), **COULEUR_ROUGE** (#FF0000), **COULEUR_GRIS** (#CCCCCC), **COULEUR_MARRON** (#673B15), **COULEUR_ROUGE_COSMO** (#B54B3A) et **COULEUR_BLEU_MARINE** (#1A03FF).

## Couleurs rayons et particules

**COULEUR_PART** = couleur de la particule √† laquelle on attribue la couleur **COULEUR_ROUGE_COSMO**.
**COULEUR_RS** = couleur du rayon de Schwarzchild √† laquelle on attribue la couleur **COULEUR_BLEU**.
**COULEUR_RPHY** = couleur du rayon physique √† laquelle on attribue la couleur **COULEUR_GRIS**. 

## Autres variables

**ifUneFois**, **ifUneFois2**, **ifUneFois3** sont des bool√©ens utilis√©s pour des v√©rifications et ils sont initialis√©s √† **true**.

## Glossaire des fonctions

#1 : testnum
#2 : testvaleur
#3 : generateur
#4 : initialisationGenerale
#5 : lancerDeFusees
#6 : supprHtml
#7 : htmlDecode
#8 : generateHtml
#9 : initialisation
#10 : verifnbr
#11 : pressionBouttonObservateur
#12 : pressionBouttonMobile
#13 : trajectoire
#14 : animate
#15 : Vr_mob
#16 : Vr_obs
#17 : Vr
#18 : potentiel_Schwarzschild_photon
#19 : derivee_seconde_Schwarzschild_photon
#20 : derivee_seconde_Schwarzschild_photon_obs
#21 : rungekutta
#22 : rungekutta_obs
#23 : calcul_rmax
#24 : pausee
#25 : clavierEvenement
#26 : rafraichir2
#27 : rafraichir
#28 : enregistrer
#29 : siTrajectoireSimple
#30 :traceEstAbsent
#31 : siTrajectoireComplete
#32 : choixTrajectoire
#33 : estUnMobile
#34 : commandes
#35 : majFondFixe
#36 : majFondFixe44
#37 : majFondFixe22
#38 : majFondFixe3
#39 : text_inte
#40 : creation_blocs
#41 : canvasAvantLancement
#42 : boutonAvantLancement
#43 : foncPourZoomPlusAvantLancement
#44 : foncPourZoomMoinsAvantLancement
#45 : foncPourVitAvantLancement
#46 : MAJGraphePotentiel

## Fonctions

### #1 : fonction testnum
üîß **Param√®tres** : a 

üí° **R√¥le** : Cette fonction chercher √† d√©terminer l'exposant de la puissance de 10 n√©cessaire pour ramener un nombre (a) donn√© dans l'intervalle [1,10].

üìë **Fonctionnement** : Je fais varier une variable i dans l'intervalle [-30,29[ et pour chaque valeur de i je divise a par 10 exposant i. Si le r√©sultat est compris dans [1,10] alors je retourne la valeur de i correspondante.

### #2 : fonction testvaleur

üîß **Param√®tres** : x

üí° **R√¥le** : Cette fonction v√©rifie si le param√®tre x est un nombre. Si c'est le cas, elle le renvoie, sinon elle retourne la cha√Æne de caract√®res 'Not a Number!'. 

üì∞ **Informations** : isNaN est une fonction en JavaScript qui permet de d√©terminer si la valeur fournie n'est pas un nombre. Si elle retourne 'true' alors la valeur fournie n'est pas un nombre. isNaN(123) par exemple va retourner false alors que isNaN('hello') va retourner true.

### #3 : fonction generateurCouleur

üîß **Param√®tres** : N/A 

üí° **R√¥le** : Cette fonction g√©n√®re et retourne de mani√®re al√©atoire une couleur RGB sous la forme d'un tableau contenant les valeurs des composantes rouge, verte et bleue.

üì∞ **Informations** : Math.random() retourne un nombre al√©atoire dans l'intervalle [0,1[ et Math.floor() arrondit un nombre √† l'entier inf√©rieur le plus proche. 

### #4 : fonction initialisationGenerale

üöß *Calculer rs sert √† rien*

üîß **Param√®tres** : fuseecompteur

üí° **R√¥le**: Cette fonction sert √† initialiser plusieurs valeurs √† partir des informations r√©cup√©r√©es sur la page html.
Elle ne retourne rien.

üìë **Fonctionnement** : 
1. On commence par fixer les constantes c (*vitesse de la lumi√®re en m/s*) et G la constante gravitationnelle.
2. Puis on r√©cup√®re les valeurs de M (*Mass de l'astre en kg*) et de r_phy (*Rayon physique de l'astre en m*) que l'utilisateur a renseign√© et on les convertis en nombres.
3. On calcule ensuite le rayon de Schwarzschild rs en deux √©tapes. D'abord en calculant (G*M)/c¬≤ puis en multipliant ce r√©sultat, stock√© dans une variable m, par 2. 
4. La derni√®re chose que cette fonction fait est d'it√©rer sur les valeurs d'une variable compteur de 1 √† la valeur de fuseecompteur inclu. pour chaque valeur de compteur elle rempli la valeur de listejsonfusees d'indice correspondant avec ce que retourne la fonction **initialisation()** qui prend comme param√®tre la valeur de compteur.

üì∞ **Informations** : Math.pow() sert √† calculer la puissance d'un nombre. Elle prend en arguments la base et l'exposant.

### #5 : fonction lancerdeFusees

üöß *calculer rs sert √† rien*

üîß **Param√®tres** : fuseecompteur

üí° **R√¥le** : Cette fonction utilise les donn√©es r√©cup√©r√©es depuis des √©l√©ments HTML et des constantes pr√©d√©finies pour lancer des fus√©es en appelant la fonction **trajectoire()** pour chaque fus√©e. 

üìë **Fonctionnement :**
1. Je commence par fixer des constantes telles que c (*vitesse de la lumi√®re en m/s*) et G (*constante gravitationnelle en SI*).
2. Puis on r√©cup√®re les valeurs de M (*Mass de l'astre en kg*) et de r_phy (*Rayon physique de l'astre en m*) que l'utilisateur a renseign√© et on les convertis en nombres.
3. On calcule ensuite le rayon de Schwarzschild rs en deux √©tapes. D'abord en calculant (G*M)/c¬≤ puis en multipliant ce r√©sultat, stock√© dans une variable m, par 2. 
4. Pour une variable compteur it√©r√©e de 1 √† fuseecompteur inclu on calcule la foncton **trajectoire** prenant comme param√®tre la valeur de compteur et la valeur de listejsonfusee[compteur] calcul√©e dans la fonction initialisationGenerale. 

### #6 : fonction supprHtml

üöß *Probl√®me initialiser nbrfuseesuppr et ENSUITE v√©rifier que ce que on a stock√© dedans existe encore*

üîß **Param√®tres** : N/A

üí° **R√¥le** : Supprimer des √©l√©ments HTML de la page web. 

üìë **Fonctionnement** : 
1. Je commence par mettre dans la variable nbrfuseesuppr la valeur de nombredefusees r√©cup√©r√©e √† partir de sessionStorage, o√π sont stock√©es les donn√©es de la session en cours.
2. Je supprime ensuite le contenu des √©l√©ments HTML avec les identifiants *tableauconstanteslers* et *tableauresultatsimu*.
3. Je v√©rifie si la variable nombredefusees existe dans sessionStorage et si c'est le cas je stocke cette valeur dans nbrfuseesuppr
4. Je r√©cup√®re un √©l√©ment HTML avec l'identifiant "myCanvas" en me servant de la m√©thode **document.getElementByID()** qui r√©cup√®re un √©l√©ment HTML √† partir de son identifiant unique (ID) dans le document HTML. Et je stocke cet √©l√©ment dans la variable elementcanvasasuppr.
5. Je supprime elementcanvasasuppr de la page.
6. Je r√©cup√®re la valeur d'un √©l√©ment de formulaire HTML avec l'ID "canvaswidthheight" et stocke cette valeur dans la variable "canvaswh".
7. Ensuite j'it√®re la variable countt de 1 √† la valeur de nbrfuseesuppr incluse et pour chaque valeur de count je supprime plusieurs √©l√©ments de la page HTML : le rayon de toutes les fus√©es, les vitesser et les vitessep ainsi que myCanvasBoule de toutes les fus√©es et les graphes d'ID "grsvg_{countt}". 
8. Une fois l'it√©ration finie je supprime de la page HTML l'√©lement d'ID "myCanvas3three".

### #7 : fonction htmlDecode

üîß **Param√®tres** : input (cha√Æne de texte)

üí° **R√¥le** : Cette fonction prend en entr√©e une cha√Æne de texte qui est suppos√©e √™tre du texte encod√© en HTML et retourne la version d√©cod√©e de ce texte. 

üìë **Fonctionnement** :
1. Je mets dans la variable doc un objet DOM qui repr√©sente le contenu HTML de input.
2. Je retourne tout le texte de la structure HTML de doc en ignorant les √©l√©ments de code HTML. 

### #8 : fonction genereHtml

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction g√©n√®re du contenu HTML en fonction de ce qui a √©t√© saisi par l'utilisateur dans un champ de formulaire avec l'identifiant "nombredefusees".
Cela va aider √† g√©n√©rer les tableaux qui apparaissent sur la page web. Celui avant le d√©but de la simulation et celui √©galement apr√®s la simulation. La taille des tableaux sera adapt√©e en fonction du nombre de mobiles.

üìë **Fonctionnement simplifi√©** : 
1. Je r√©cup√®re la valeur de "nombredefusees" √† partir du formulaire.
2. Je g√©n√®re plusieurs √©l√©ments HTML comme des √©tiquettes (labels) et des champs de saisie (inputs) en fonction du nombre de fus√©es qui a √©t√© sp√©cifi√©.
3. J'attribue des ID uniques √† chaque √©l√©ment g√©n√©r√© en utilisant une boucle for.
4. J'ins√®re les √©l√©ments g√©n√©r√©s dans un conteneur avec l'identifiant "champs_a_remplir" dans le document HTML.
5. Je cr√©√© une ligne de tableau avec des en-t√™tes contenant des √©tiquettes num√©rot√©es et les ins√®re dans un tableau avec l'identifiant "**tableauconstanteslers**".
6. Dans ce tableau il y aura les constantes d'int√©gration E et L pour chaque mobile (voir la partie th√©orique), le rayon de Schwarzschild, la gravit√©, la vitesse de lib√©ration, la temp√©rature d'un trou noir et le temps d'√©vaporation d'un trou noir.
7. Dans cette fonction on cr√©e aussi un nouveau tableau cette fois sous l'identifiant "**tableauresultatsimu**" o√π seront rang√©s les r√©sultats de la simulation pour chaque mobile. Pour chaque mobile on aura des r√©sultats sp√©cifiques comme la position le temps √©coil√© etc. La taille de ce tableau (le nombre de canvas) sera adapt√© en fonction du nombre de fus√©es.

üì∞ **Informations** : Les fonctions **texteTrajectoirePhoton(nbredefuseesgenere)**, **notationvitesseree1()**, **textegravetetc()**, **infobilleobservateurdistant()** sont utilis√©es. Ainsi que d'autres fonctions servant au bon affichage du katex qui permet d'avoir de belles formules LateX sur le site.

## #9 : fonction initialisation

üöß *Pourquoi une condition sur theta=90 ou 180¬∞ ? Et pourquoi faire les calculs avant d'avoir v√©rifi√© les conditions ? phi0 convertit en degr√©s puis en radians √† nouveau ?*

üîß **Param√®tres :** compteur

üí° **R√¥le** : Cette fonction effectue plusieurs calculs et actions pour initialiser les donn√©es d'un mobile/fus√©e sp√©cifique dans la simulation.

üìë **Fonctionnement d√©taill√© :**
1. Je fixe mes variables de la vitesse de la lumi√®re en m/s (*c*) et de la constante gravitationnelle G en SI.
2. Je r√©cup√®re la masse de l'astre en kg rentr√©e par l'utilisateur dans la variable M et le rayon physique de l'astre en m rentr√© par l'utilisateur dans la variable r_phy.
3. Je calcule la valeur du rayon de Schwarzschild et je le stocke dans la variable rs.
4. Je r√©cup√®re la valeur de la distance initiale du projectile au centre de l'astre (en m) pour le mobile donn√© par le param√®tre compteur et je stocke cette valeur dans la variable r0.
5. Je r√©cup√®re la valeur de l'angle de d√©part œÜ du mobile consid√©r√© par le param√®tre compteur et je stocke cette valeur dans la variable phi0. 
6. Je r√©cup√®re la valeur de l'angle de d√©part de la vitesse Œ∏ du mobile consid√©r√© par le param√®tre compteur et je stocke cette valeur dans la variable teta.
7. Je stocke dans la variable teta1 la valeur de teta.
8. Je convertis phi0 et teta en radians.
9. Je calcule la valeur de la vitesse tangentielle vœÜ pour ce mobile et je stocke cette valeur dans la variable vphi.
10. Je calcule la valeur de la vitesse radiale vr pour ce mobile et je stocke cette valeur dans la variable vr.
11. Je d√©clare que si mon angle Œ∏ fait 180¬∞ alors vœÜ sera nule et si il fait 90¬∞ alors vr sera nulle.
12. Je calcule les constantes d'int√©grations L et E que je stocke respectivement dans les variable L et E. 
13. Je mets √† jour les contenus des √©l√©ments HTML avec les identifiants "L", "E" et "rs" avec les valeurs que je viens de calcul√©e dans cette fonction avec une notation exponentielle √† 3 chiffres significatifs.
14. Je r√©cup√®re la valeur de l'√©l√©ment HTML avec l'ID "scalefactor" et je la convertit en nombre plus la stocke dans la variable "scale_factor".
15. Je cr√©√© un nouvel objet JavaScript appel√© "mobile" et je lui attribu plusieurs propri√©t√©s : les valeurs r0, vphi, vr, L, E et phi0 que je viens de calculer ou r√©cup√©rer.
16. J'ajoute √† l'objet "mobile" une nouvelle propri√©t√© "pointsvg" consitut√©e de la cha√Æne de carac√®tre "pointg" suivie du param√®tre compteur (le num√©ro de mobile) consid√©r√©.
17. J'ajoute √† l'objet "mobile" une nouvelle propri√©t√© "graphesvg" constitu√© de la chaine de carat√®re "#grsvg_" suivie du param√®tre compteur (le num√©ro de mobile) consid√©r√©.
18. J'ajoute √† l'objet "mobile" une nouvelle propri√©t√© "onestarrete" avec comme valeur initiale 0. Probablement pour savoir si le mobile est arr√™t√© ou non.
19. J'ajoute √† l'objet "mobile" une nouvelle propri√©t√© "peuxonrelancer" avec comme valeur initiale true. Probablement pour savoir si on peut continuer la trajectoire apr√®s un arr√™te ou non.
20. J'effectue le calcul de rmax avec la fonction **calcul_rmax(L,E,vr,r0,1)** et je rajoute cette valeur de rmax comme propri√©t√© √† l'objet mobile sous le nom "rmax".
21. J'ajoute √† l'objet "mobile" une nouvelle propri√©t√© "blups" avec comme valeur initiale 0.
22. Je stocke la valeur de rmax dans un tableau "rmaxjason" √† l'index sp√©cifi√© par le param√®tre compteur.
23. Je stocke la valeur de "scale_factor" dans un tableau "mobilefactor" √† l'index sp√©cif√© par le param√®tre compteur. 
24. Je stocke la valeur de r0 dans un tableau "r0o2" √† l'index sp√©cifi√© par le param√®tre compteur.
25. J'initiale la propri√©t√© "pause" de l'objet "mobile" avec la valeur true.
26. J'initialise la propri√©t√© "d√©but" de l'objet "mobile" avec la valeur true.
27. J'ajoute √† l'objet "mobile" des param√®tres pour y associer une couleur g√©n√©r√©e de mani√®re al√©atoire gr√¢ce √† la fonction generateCouleur().
28. Je calcule la valeur de la gravit√© g et si la valeur du rayon physique r_phy de l'astre est nulle je mets √† jour le contenu HTML de l'√©l√©ment avec l'ID "g" avec une cha√Æne vide. Par contre si r_phy est diff√©rent de 0 alors je mets √† jour l'√©l√©ment "g" avec la valeur de g que je viens de calculer.
29. Si le rayon de Schwarzschild rs est plus grand que le rayon physique de l'astre rs alors je calcule la temp√©rature du trou noir et je mets √† jour le contenu HTML de l'√©l√©ment avec l'ID "TempTN" avec cette valeur calcul√©e stock√©e dans la variable Temp_trouNoir. Et je calcule √©galement de mani√®re simplifi√© le temps d'√©vaporation de Hawking que je stocke dans la variable tempsEvaporation_trouNoir et je mets √† jour le contenu HTML de l'√©l√©ment avec l'ID "tempsEvapTN" avec la valeur de tempsEvaporation_touNoir. Mais si la condition du rayon de Schwarzschild n'est pas v√©rifi√©e alors je mets √† jours les deux √©l√©ments cit√©s pr√©c√©demment avec une cha√Æne vide car cela signifie qu'il n'y a pas de trou noir.
31. Je calcule la vitesse de lib√©ration √† la surface de l'astre et je stocke ce calcul dans la variable vlib. Si le rayon physique de l'astre r_phy est plus grand ou √©gal au rayon de Schwarzschild (si on a pas un trou noir) alors je mets √† jour le contenu HTML de l'√©l√©ment avec l'ID "Vlib" avec la valeur de la variable vlib et dans le cas contraire je le mets √† jour avec une cha√Æne de caract√®re vide.
32. Si le param√®tre compteur est √©gal √† 1 alors je stocke dans une variable "vphiblab" la valeur de la vitesse de la lumi√®re c et dans "vrblab" la valeur de phi0 en degr√©s. 
33. Si le param√®tre compteur est √©gal √† 2 alors je stocke dans une variable "phi2i" la valeur de la vitesse de la lumi√®re c et dans une variable "vr2i" la valeur de phi0 en degr√©s. 
34. J'appelle les fonctions **boutonAvantLancement()** et **canvasAvantLancement()**.


üì∞ **Informations** : Cette fonction utilise les autres fonctions **calcul_rmax()**, **generateCouleur()**, **boutonAvantLancement()** et **canvasAvantLancement()**. 

## #10 : fonction verifnbr

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction alerte l'utilisateur si des champs obligatoires ne sont pas remplis ou bien si ils contiennent des valeurs incorrectes. 

üìë **Fonctionnement simplifi√©** :
1. Je r√©cup√®re les valeurs de la masse de l'astre en kg (stock√©e dans M) , du rayon physique de l'astre (stock√©e dans r_phy) et du nombre de mobiles (stock√©e dans sddsdsdds) renseign√©s par l'utilisateur. 
2. Pour chacun des mobiles je r√©cup√®re la valeur de la distance initiale du projectile au centre de l'astre en m (stock√©e dans r0verifnbf), la valeur de la vitesse tangentielle vphi (stock√©e dans vphiverifnbr) et la valeur de la vitesse radiale vr (stock√©e dans vrverifnbr).
3. Je v√©rifie si r0verifnbr, vphiverifnbr et vrverifnbr pour tous les mobiles sont des nombres et si ce n'est pas le cas j'affiche des messages d'erreur en cons√©quence.
4. Je v√©rifie que r_phy et M soient des nombres et si ce n'est pas le cas j'affiche des messages d'erreur en cons√©quence.

## #11 : fonction pressionBouttonObservateur

üîß **Param√®tres** : N/A

üí° **R√¥le** : Changer les classes CSS des boutons avec les identifiants "r3" et "r4" si on appuie sur le bouton "r3". 

üìë **Fonctionnement** :
* Je regarde si la classe du bouton avec l'identifiant "r3" est √©gale √† "myButton2" et si c'est le cas alors cela veut dire que le bouton est activ√©. Dans ce cas je change la classe du bouton "r3" en "myButton" et celle du bouton "r4" en "myButton2". 

## #12 : fonction pressionBouttonMobile

üîß **Param√®tres** : N/A

üí° **R√¥le** : Changer les classes CSS des boutons avec les identifiants "r3" et "r4" si on appuie sur le boutton "r4". 

üìë **Fonctionnement** :
* Je regarde si la classe du bouton avec l'identifiant "r4" est √©gale √† "myButton2" et si c'est le cas alors cela veut dire que le bouton est activ√©. Dans ce cas je change la classe du bouton "r4" en "myButton" et celle du bouton "r3" en "myButton2". 

## #13 : fonction trajectoire 

üöß *Variable nomm√©e BLYO pour le nombre de mobiles puis nbredefusees dans laquelle y a exactement la m√™me chose*

üîß **Param√®tres** : compteur, mobile

üí° **R√¥le** : Etablir la trajectoire de la particule.

üìë **Fonctionnement d√©taill√©**:
1. Je stocke dans la variable "texte" ce que me retourne la fonction **o_recupereJson()**.
2. Je v√©rifie si la trajectoire est en pause ou bien si elle vient de d√©marrer et si une de ces conditions est v√©rifi√©e alors j'effectue diff√©rentes action : <br>
üîπ  La couleur du champ de saisie de r0 est modifi√©e en fonction des composantes de couleurs d√©finies dans l'objet mobile (de la couleur qui est associ√©e √† ce mobile) et la couleur du texte est ajust√©e en noir ou blanc en fonction de la luminosit√© du champ de saisie. <br>
üîπ L'√©l√©ment avec l'ID "tg2" est modifi√© pour afficher le style de table. (Affichage d'un √©l√©ment HTML sous forme de tableau.) Et le contenu de l'√©lement avec l'ID "indic_caluls" est remplac√© par le texte r√©cup√©r√© √† partir de **texte.pages_trajectoire.calculs_encours**, ce qui semble √™tre un indicateur visuel pour l'utilisateur indiquant que des calculs sont en cours. <br>
üîπ La fonction **estUnMobile()** est appell√©e. <br>
üîπ Certains √©l√©ments de saisie dans le document HTML sont d√©sactiv√©s pour √©viter que l'utilisateur ne modifie les valeurs pendant la simulation. Les √©l√©ments affect√©s sont la masse de l'astre (M), le rayon physique de l'astre (r_phy) et le nombre de mobiles (nombredefusees). <br>
üîπ Je r√©cup√®re le nombre de mobiles que l'utilisateur a rentr√© et je stocke cette valeur convertie en nombre dans la variable blyo. <br>
üîπ Je boucle et pour tous les mobiles je d√©sactive les champs de saisie associ√©s √† r0, phi0 et teta pour ne pas que l'utilisateur ne modifie les valeurs pendant la simulation. <br>
üîπ Je d√©sactive les boutons qui permettent  de passer d'observateur √† photon et vice-versa. Ainsi l'utilisateur ne peut pas les changer en pleine simulation. <br>
üîπ Je d√©finis la valeur de l'√©l√©ment avec l'ID "trace_present" √† "1" pour contr√¥ler si il y a un trac√© pendant la simulation ou non pour l'enregistrement. <br>
üîπ Je d√©finis les propri√©t√©s "pause" et "d√©but" de l'objet "mobile" √† false. Cela indique ainsi que la simulation n'est ni en pause ni au d√©but. <br>
üîπ J'initialise les valeurs des angles "phi" et "phi_obs" dans l'objet "mobile" avec la valeur phi0 de l'objet mobile. <br>
üîπ Je calcule le temps de chute libre ("temps_chute_libre") de la particule. <br>
üîπ J'ajoute la propri√©t√© "temps_chute_libre" √† l'objet "mobile" et je l'initialise avec la valeur de ma variable temps_chute_libre que je viens de calculer. <br>
üîπ Je stocke dans la variable "A_init" la valeur de vr du mobile et dans la variable "r_init" la valeur de r0 du mobile. <br>
üîπ Je stocke dans la variable "nbredefusees" la m√™me chose que dans la variable "blyo". <br>
üîπ Si le nombre de mobile est √©gale √† 1 et que "ifUneFois2" (initialis√©e √† true au d√©but du programme) est √©gale √† true alors on stocke dans la variable maximum la valeur de rmax associ√©e √† l'indice 1 de la liste r0o2. Et puis on stocke dans la variable "cle" la valeur 1 et dans la variable ifUneFois2 la valeur false. <br>
üîπ Si le nombre de mobile est plus grand ou √©gal √† 2 et que "ifUneFois" (initialis√©e √† true au d√©but du programme) est √©gale √† true (premi√®re fois que cette condition est rencontr√©e) alors on fait plusieurs choses. Tout d'abord on cherche le mobile ayant le rayon le plus √©lev√© (rmax) parmi tous les mobiles et on stocke la valeur de rmax de ce mobile dans la variable "maximum" et le num√©ro de ce mobile dans la variable "cle". Ensuite je parcours √† nouveau toutes les fus√©es et j'ajuste les facteurs de mise √† l'√©chelle ("mobilefactor") pour qu'ils soient proportionnels au rayon du mobile le plus grand. Pour finir je mets la variable "ifUneFois" √† false. <br>
üîπ On stocke dans la variable "A_part" la valeur de "A_init" et dans la variable "r_part" la valeur de "r_init". <br>
üîπ J'ajoute √† l'objet "mobile" les propri√©t√©s "A_part" et "r_part" que j'initialise avec les variables aux noms correspondant. <br>
üîπ Je calcule la vitesse radiale vr du mobile observ√©e que je stocke dans la variable "A_init_obs", je stocke ensuite √©galement cette valeur dans la variable "A_part_obs" et j'ajoute √† l'objet "mobile" une propri√©t√© "A_part_obs" que j'initialise avec A_part_obs. <br>
üîπ Je stocke dans la variable "vrobs" la valeur de la variable "A_init_obs". <br>
üîπ Je calcule la valeur de la vitesse tangentielle observ√©e que je stocke dans la variable "vphiobs". <br>
üîπ Je stocke dans les variable "r_init_obs" et "r_part_obs" la valeur de la distance initiale du mobile au centre de l'astre r0 du mobile.Et puis j'ajoute √† l'objet "mobile" la propri√©t√© "r_part_obs" que j'initialise avec r_part_obs. <br>
üîπ J'initialise le temps de la particule (temps_particule) et le temps de l'observateur (temps_observateur) √† 0 et j'ajoute √† l'objet "mobile" les propri√©t√©s "temps_particule" et "temps_observateur" que j'initialise avec mes nouvelles variables. <br>
üîπ J'appelle la fonction clavierEvenement(). <br>
üîπ Je r√©cup√®re dans la variable "element2" l'√©l√©ment HTML avec l'ID "traject_type2". <br>
üîπ Je calcule la valeur de dœÑ que je stocke dans la variable "dtau" et puis j'ajoute √† l'objet "mobile" la propri√©t√© "dtau" que j'initialise avec ma nouvelle variable. <br>
üîπ Je calcule la position initiale de la particule (x1part et y1part) en ajustant la taille de la trajectoire sur le canva et en normalisant la position par rapport √† la taille maximale de la trajectoire. <br>
üîπ Je calcule la position initiale de l'observateur dans le r√©f√©rentiel propre (x1obs et y1obs) en ajustant la taille de la trajectoire sur le canva et en normalisant la position par rapport √† la taille maximale de la trajectoire. <br>
üîπ Je r√©cup√®re l'√©l√©ment HTML avec l'ID "myCanvas" et je le stocke dans la variable canvas. Puis je v√©rifie si canvas est d√©fini et si ce n'est pas le cas j'affiche un message d'erreur contenue dans **texte.pages_trajectoire.impossible_canvas**. <br>
üîπ Je r√©cup√®re le contexte de rendu 2D du canvas et je le stocke dans la variable context. Si context n'est pas d√©fini alors j'affiche un message d'erreur contenue dans **texte.pages_trajectoire.impossible_context**.  <br>
üîπ J'ajoute √† l'objet "mobile" la propri√©t√© "canvas22" qui est initialis√©e avec un √©l√©ment canvas avec l'ID "myCanvasBoule"+{num√©ro du Mobile}. <br>
üîπ J'ajoute √† l'objet "mobile" la propri√©t√© "context22" qui est initialis√©e avec le contexte de rendu 2D. <br>
üîπ J'appelle la fonction **majFondFixe()** et la fonction **majFondFixe44()** avec le param√®tre mobile. <br>
üîπ Je stocke dans la variable diametre_particule la valeur DIAMETRE_PART qui a √©t√© initialis√©e au d√©but du programme. <br>
üîπ Je modifie le style de l'√©l√©ment HTML ayant l'ID "bloc_resultats" pour afficher ce bloc en tant que block. Donc l'√©l√©lement HTML avec cet ID sera rendu visible sur la page web. <br>
üîπ Je d√©fini une fonction appell√©e **CentrerPopPotentiel()** qui ne prend pas de param√®tres et qui affiche d'abord un √©l√©ment HTML avec l'ID "bloc_resultats" en le rendant visible sur la page ensuite elle parcourt une s√©rie d'√©lements HTML ayant des IDs de la forme "grsvg_{num√©ro du mobile}" et pour chaque √©l√©ment trouv√© elle le supprime du DOM s'il existe et a un parent. Enfin, si la case √† cocher ayant l'ID "toggle" est d√©coch√©e alors la fonction **CentrerPopPotentiel()** est appell√©e. Cette fonction permet donc de nettoyer et de r√©initialiser certaines parties de la page lorsque l'utilisateur d√©coche une cas √† cocher. <br>
üîπ Je calcule la position de la particule sur le canvas avec les variables x1part et y1 part puis je stocke ces positions dans une propri√©t√© "positionspatio" de l'objet "mobile". <br>
üîπ Je calcule la position de l'observateur sur le canvas avec les variable x1obs et y1obs puis je stocke ces positions dans une propri√©t√© "position" de l'objet "mobile". <br>
üîπ Je calcule la position centrale du canvas (la moiti√© de sa largeur et la moiti√© de sa hauteur) et je la stocke dans les variable "posX3" et "posY3". <br>
üîπ J'anime la simulation en appelant la fonction **animate()** √† intervalles r√©guliers en en lui fournissant les arguments "compteur", "mobile" et "mobilefactor". <br>
üîπ Je stocke dans les propri√©t√©s "Dtau1" et "Dtau2" du mobile les valeurs de Dtau √† la puissante 8 (*1e8) (Dtau1) et de Dtau √† la puissance -8 (/1e8) (Dtau2).<br>
üîπ J'associe un √©v√©nement de clic √† un bouton ayant l'ID "bouton_pause". Lorsque ce bouton est cliqu√©, la fonction **pausee()** est appell√©e prenant comme arguments "compteur", "mobile" et "mobilefactor". <br>
üîπ Je supprime un √©couteur d'√©v√©nements associ√© au bouton d'ID "plusvite" et un autre √©couteur d'√©v√©nement associ√© au bouton d'ID "moinsvite". <br>
üîπ J'ajoute un nouvel √©couteur d'√©venement au bouton "plusvite" qui lorsqu'il est cliqu√© va faire que la vitesse de la simulation est augment√©e √† l'aide de la fonction **bouttons.vitesse(mobile,true)** et la variable "compteurVitesseAvantLancement" est √©galement mise √† jour pour refl√©ter la nouvelle vitesse de la simulation. <br>
üîπ J'ajoute un nouvel √©couteur d'√©v√©nement au bouton "moinsvite" qui lorsqu'il est cliqu√© va faire que la vitesse de la simulation va baisser √† l'aide de la fonction **bouttons.vitesse(mobile, false)** et la variable "compteurVitesseAvantLancement" est √©galement mis √† jour pour refl√©ter la nouvelle vitesse de la simulation. <br>
üîπ J'ajuste la vitesse de simulation en fonction du nombre de clics sur les boutons "plusvite" ou "moinsvite".<br>
üîπ Lorsque l'on clique sur le bouton d'ID "enregistrer2" alors une action est d√©clench√©e. On r√©cup√®re l'√©l√©ment d'ID "traject_type2" et si cette valeur n'est pas "mobile" alors √ßa veut dire que l'observateur est s√©lectionn√© et dans de cas on dessine un cercle bleu sur le canvas √† la position actuelle de l'observateur. Si la valeur est "mobile" alors cela veut dire que la particule est s√©lectionn√©e et dans de cas on dessine un cercle bleu sur le canvas √† la position actuelle de la particule. <br>
üîπ Les √©couteurs d'√©v√©nements associ√©s aux boutons d'ID "moinszoom" et "pluszoom" sont supprim√©s pour √©viter les doublons, au cas o√π ils auraient d√©j√† √©t√© ajout√©s pr√©c√©demment. <br>
üîπ Un nouvel √©couteur d'√©v√©nement est ajout√© au bouton "moinzoom". Lorsque ce bouton est cliqu√© la fonction **bouttons.zoom(false, mobile, canvas, mobilefactor, compteur)** est appel√©e pour r√©duire le zoom. Puis les facteurs de zoom et les valeurs associ√©es sont mis √† jour et la fonction **majFondFixe44(mobile)** est appel√©e pour mettre √† jour le fond fixe. Pour finir la fonction **rafraichir2(context, mobilefactor, rmaxjson, maximum, compteur)** est appel√©e pour rafra√Æchir le canvas et le texte affichant le niveau de zoom est mis √† jour. <br>
üîπ Un √©couteur d'√©venement similaire est ajout√© au bouton "pluszoom" mais cette fois pour augmenter le zoom. <br>
üîπ Un dernier √©couteur d'√©v√©nement est ajouter au bouton d'ID "initialiser" qui r√©initialise les param√®tres de la simulation lorsque le bouton est cliqu√©. Cela inclut la r√©initialisation des facteurs de zoom, l'appel de la fonction **majFondFixe44(mobile)** pour mettre √† jour le fond fixe, le rafraichissement du canvas et la r√©initialisation du texte affichant le niveau de zoom. <br>
üîπ J'ajoute un √©couteur d'√©v√©nement au bouton d'ID "clear". Lorsque ce bouton est cliqu√©, la page est recharg√©e ce qui a pour effet d'effacer le contenu du canvas en entier puisque tout le script sera relanc√©. <br>
üîπ La fonction **creation_blocs(context, mobilefactor, rmaxjson, maximum, compteur)** est appel√©e et semble √™tre responsable du trac√© du rayon de Schwarzchild. <br>
üîπ On stocke dans une variable "element2" l'√©l√©ment dont l'ID est "traject_type2". <br>
üîπ Je cr√©√© un intervalle d'ex√©cution qui ex√©cute la fonction anonyme toutes les 300 milisecondes, ceci va √™tre utilis√© pour des mises √† jour en temps r√©el ou des animations. Ce bloc de code va √™tre responsable de la mise √† jour p√©riodique du graphe du potentiel en fonction du type de trajectoire s√©lectionn√© (observateur ou spationaute). <br>
üîπ Voici ce que fais cette fonction anonyme : Elle commence par vider l'√©l√©ment SVG identifi√© par "grsvg_" suivi du num√©ro de compteur. Cela permet de nettoyer le contenu SVG avant de dessiner de nouveaux √©l√©ments.Ensuite elle initialise deux tableaux de donn√©es vide "data1" et "data2". Puis elle v√©rifie si la valeur de l'√©l√©ment "element2" n'est pas mobile et si c'est le cas elle calcule le pas de variation "dr" pour le trac√© du graphe en fonction du rayon de la particule observ√©e, calcule les valeur du potentiel gravitationnel pour diff√©rents pourcentages de rayon du rayon de la particule observ√©e et les stocke dans "data1", calcule la valeur du potentiel gravitationnel au rayon de la particule observ√©e et la stocke dans "data2", puis appelle la fonction **graphique_creation_pot(0, data1, data2, compteur, mobile)** pour cr√©er le graphe du potentiel avec les donn√©es calcul√©e et le stocke dans mobile.point. Si la valeur de "element2" est "mobile" alors le processus est similaire mais les calculs sont bas√©s sur le rayon de la particule plut√¥t que sur celui de la particule observ√©e. <br>
3. Si la trajectoire n'est pas en pause ou vient de d√©marrer alors on cr√©√© un intervalle qui ex√©cute la fonction **animate.bind(null, compteur, mobile, mobilefactor)** p√©riodiquement et on stocke cet intervalle dans mobile.myInterval. 10/6 est l'intervalle de temps en miliseconde entre chaque appel de la fonction **animate()**.
4. Un √©v√©nement est ajout√© au bouton d'ID "pause/resume" de sorte que lorsque ce bouton est cliqu√© la fonction **pausee(compteur, mobile, mobilefactor)** est appell√©e.
5. Le bouton d'ID "start" est masqu√© une fois que l'animation est lanc√©e.
6. Le bouton d'ID "pause/resume" est affich√© une fois que l'animation est lanc√©e.
7. Une info-bulle est ajout√©e au bouton d'ID "clear" avec le texte sp√©cifi√© dans **texte.pages_trajectoire.bouton_stop_bulleInfo**.


üì∞ **Informations** : Cette fonction utilise les autres fonctions **o_recupereJson()**, **texte.pages_trajectoire.calculs_encours**, **estUnMobile()**, **clavierEvenement()**, **texte.pages_trajectoire.impossible_canvas**, **texte.pages_trajectoire.impossible_context**, **majFondFixe()**, **majFondFixe44()**, **animate()**, **pausee()**, **vitesse()** et **zoom()** li√©es au fichier **bouttons.js**, **rafraichir2()**, **creation_blocs()**, **graphique_creation_pot()**, **pausee()**, **texte.pages_trajectoire.bouton_stop_bulleInfo**.
Le **DOM** est une repr√©sentation hi√©rarchique sous forme d'arbdre de tous les √©l√©ments d'une page web o√π chaque √©l√©ment est un noeud dans cet arbre.

## #14 : fonction animate 

üöß *Pourquoi une fonction testvaleur(x) est red√©finie dans cette fonction alors qu'elle l'a d√©j√† √©t√© faites en dehors ? Il y a un += 0 ? J'ai un /0 √† la ligne 1056 ?*

üîß **Param√®tres** : compteur, mobile, mobilefactor

üí° **R√¥le** : Cette fonction g√®re l'animation de la trajectoire d'une particule autour d'un trou noir, √† la fois dans le r√©f√©rentiel propre de la particule et dans celui de l'observateur.

üìë **Fonctionnement d√©taill√©** :
1. J'initialise la variable "onestarrete" de l'objet "mobil" √† 0 pour indiquer que la particule n'est pas arr√™t√©e.
2. Je met √† jour le facteur de zoom de la trajectoire de la particule dans le tableau "mobilefactor" √† l'indice "compteur" avec la valeur de la variable "factGlobalAvecClef".
3. J'appelle la fonction **estUnMobile()**.
4. Je r√©cup√®re l'√©l√©ment HTML avec l'ID "traject_type" que je stocke dans la variable "element"
5. J'appelle la fonction **choixTrajectoire(compteur, context, mobile, mobilefactor, rmaxjson, maximum)** pour probablement choisir le type de trajectoire √† afficher en fonction de certains param√®tres pass√©s en arguments.
6. Je r√©cup√®re la valeur de l'√©l√©ment HTML avce l'ID "boutton_ammorti" que je stocke dans la variable "isrebond".
7. Je v√©rifie si r0 (la distance initiale du mobile au centre de l'astre) est diff√©rente de 0.0 ou non et si c'est le cas :<br>
üîπ Si la valeur de "element2" est "mobile" alors la fonction **rungekutta(mobile.L, mobile.dtau, mobile.r_part, mobile.A_part)**  qui semble utiliser la m√©thode de Runge-Kutta est appel√©e pour calculer les nouvelles positions et vitesses de la particule mobile puis stocke les r√©sultats dans les propri√©t√©s "rpart" et "A_part" de l'objet "mobile". Je stocke ensuite dans la variable resultat ce que retourne la fonction **calculs.MSC_Ex_vitess(mobile.e, mobile.L, mobile.r_part, rs, true)**. Ensuite je stocke dans la variable "vtotal" le r√©sultat resultat[0] (probablement la vitesse totale de la particule), dans "vp_2" le resultat[2] (probablement la vitesse tangentielle de la particule) et dans "vr_2" le resultat[1]xMath.sign(mobile.A_part) (probablement la vitesse radiale de la particule). <br>
üîπ Sinon j'effectue des calculs assez similaires pour le cas o√π l'"element2" n'est pas "mobile". Les noms de variables changeront par contre avec un "_obs" qui appara√Æt √† la fin et on utilisera non pas **rungekutta()** mais **rungekutta_obs()**. <br>
üîπ Je v√©rifie si la valeur de l'√©l√©ment "element2" n'est pas "mobile" et en fonction : <br>
üîπüîπüîπ Soit  Si "element2" n'est pas "mobile" et que le "r_part_obs" est sup√©rieur ou √©gal √† "rs" alors on trace la trajectoire de la particule. On dessine un petit rectangle repr√©sentatnt la particule sur le canvas et les coordonn√©es de la particule sont donn√©es par "mobile.position.posX2" et "mobile.position.posY2". Ensuite le code met √† jour le contexte mobile["context22"] pour dessiner un cercle autour de la particule, pour la distinguer sur le deuxi√®me canva.<br>
üîπüîπüîπ Ou bien si "element2" est "mobile" on est dans le r√©f√©rentiel de la particule et le m√™me processus est r√©alis√© mais cette fois les coordonn√©es de la particule sont "mobile.positionspation.posX1" et "mobile.positionspatio.posY1"<br>
üîπ Si on a "element2" qui n'est pas "mobile" et donc qu'on est dans le r√©f√©rentiel de l'observateur et que "r_part_obs" est plus petit ou √©gal √† "r_phy"  alors si l'option de rebond est activ√© (isrebond=1) et que le "r_phy" > 0  alors on inverse le signe de "mobile.A_part_obs" .Si par contre le rebond est d√©sactiv√© (isrebond=0), que r_phy est diff√©rent de 0 et que "mobile.r_part_obs" est plus petit ou √©gale √† "r_phy" alors on met la variable "mobile.onestarrete" √† 1, on appelle la fonction arret(mobile) et on met la variable "mobile.peuxonrelancer" √† false.<br>
üîπ Si par contre on a "element2" qui est "mobile" et que donc on est dans le r√©f√©rentiel de la particule et que "mobile.r_part" est plus petit ou √©gal √† "r_phy" ou bien que mobile.r_part==0 alors on a deux cas de figure. Soit l'option de rebond est activ√© et r_phy >  et dans ce cas on inverse le signe de mobile.A_part. Ou bien l'option rebond est d√©sactiv√©e et r_phy n'est pas nulle et mobile.r_part <= r_phy et dans ce cas on fait les m√™mes choses que dans le deuxi√®me cas du point 9.<br>
üîπ  Ensuite on met √† jour les positions de la particule dans son r√©f√©rentiel et dans le r√©f√©rentiel de l'observateur sur le canva en fonction de leur position radiale et angulaire.<br>
üîπ  Si le choix de la trajectoire (element2.value) n'est pas"mobile" alors on utilise la fonction **Vr_obs(mobile.E,mobile.L,mobile.r_part_obs)** pour calculer le potentiel gravitationnel et le r√©sultat est stock√© dans la variable V. Ensuite, une nouvelle liste de donn√©es ("data2") est cr√©√©e, contenant une seule entr√©e avec dans "date" la variable "mobile.r_part_obs" et dans "close" la variable "V". Et puis si la variable "mobile.point" est d√©finie alors on appelle la fonction **update_graphique_2(mobile.point,data2,mobile)**.<br>
üîπ  Si "element2" est √©gal √† "mobile" alors on utilise la fonction **Vr_mob(mobile.L,mobile.r_part)** pour calculer le potentiel gravitationnel qui est stock√© dans "V" et de la m√™me mani√®re on cr√©√© une liste de donn√©e "data2" sauf que cette fois dans "date" on met la variable "mobile.r_part". Et puis on on proc√®de de la m√™me mani√®re que dans 12.<br>
üîπ  Je v√©rifie si mobile.rpart est n√©gatif ou pas et si c'est le cas je le remets √† 0. Ceci est fait pour ne pas avoir de mauvaises surprises sur le dernier calcul avant la fin. <br>
üîπ  Je d√©fini ensuite une fonction **testvaleur(x)** qui v√©rifie si le param√®tre x qui lui est donn√© est un nombre ou non et si c'est un nombre alors la fonction le retourne et si ce n'est pas le cas elle affiche un message d'erreur. <br>
üîπ  Je v√©rifie si "element2" est √©gal √† "mobile" (r√©f√©rentiel de l'observateur) ou pas (r√©f√©rentiel du photon). Et puis je v√©rifie quelques conditions suppl√©mentaires comme par exemple si "mobile.r_part_obs" >= rs * 1.000001 ou si "mobile.r_part">0 et en fonction des conditions qui sont remplie ou non je mets √† jours les valeurs HTML des √©l√©ments d'ID "to{compteur}", "r_par{compteur}", "tp{compteur}", "vp_sc_mas{compteur}", "vr_sc_mas{compteur}", "v_tot{compteur}", "ga{compteur}". <br>
üîπ Si on est dans le r√©f√©rentiel de la particule et que "mobile.r_part" > rs*1.00001 alors on rajouter √† la valeur "mobile.temps_observateur" la valeur de "mobile.dtau". Et si on ne v√©rifie pas la condition "mobile.r_part" > rs*1.00001 alors "mobile.temps_observateur" prend la valeur 1/0. **GROS PROBLEME A CET ENDROIT**.Je mets ensuite √† jour la valeur de l'√©l√©ment HTML qui a pour ID "to{compteur}" peu importe si la condition est v√©rifi√©e ou non. <br>

üì∞ **Informations** : Cette fonction utilise les autres fonctions **estUnMobile()**, **choixTrajectoire()**, **rungekutta()**, **MSC_Ex_vitesse()** li√©e au fichier **calculs**, **rungekutta_obs()**, **arret()**, **Vr_obs()**, **update_graphique_2()**

## #15 : fonction Vr_mob

üöß *Pourquoi ?*

üîß **Param√®tres** : L, r

üí° **R√¥le** : Cette fonction retourne la valeur que donne la fonction **potentiel_Schwarzschild_photon(L,r)** qui devrait √™tre le potentiel gravitationnel dans le r√©f√©rentiel de la particule.

## #16 : Fonction Vr_obs

üîß **Param√®tres** : E,L,R

üí° **R√¥le** : Cette fonction retourne le potentiel gravitationnel dans le r√©f√©rentiel de l'observateur en utilisant la fonction **potentiel_Schwarzschild_photon(L,r)**, la constante d'int√©gration E ainsi que r et le rayon de Schwarzschild rs.

## #17 : fonction Vr

üöß *Pourquoi ?*

üîß **Param√®tres** : L, r

üí° **R√¥le** : Cette fonction retourne la valeur que donne la fonction **potentiel_Schwarzschild_photon(L,r)** qui devrait √™tre le potentiel gravitationnel.

## #18 : fonction potentiel_Schwarzschild_photon

üîß **Param√®tres** : L, r

üí° **R√¥le** : Cette fonction retourne le potentiel gravitationnel en m√©trique de Schwarzschild pour le photon. Pour cela elle se sert du rayon de Schwarzschild rs.

## #19 : fonction derivee_seconde_potentiel_Schwarzschild_photon

üîß **Param√®tres** : L, r

üí° **R√¥le** : Cette fonction retourne la d√©riv√©e seconde selon r du potentiel effectif en m√©trique de Schwarzschild pour le photon. Pour cela elle se sert du rayon de Schwarzschild rs.

## #20 : fonction derivee_seconde_potentiel_Schwarzschild_photon

üîß **Param√®tres** : E, L, r

üí° **R√¥le** : Cette fonction retourne la d√©riv√©e seconde selon r du potentiel effectif en m√©trique de Schwarzschild pour le photon dans le r√©f√©rentiel de l'observateur. Pour cela elle se sert du rayon de Schwarzschild rs.

## #21 : fonction rungekutta

üîß **Param√®tre** : L, h, r, A

üí° **R√¥le** : Cette fonction utilise la m√©thode de Runge-Kutta d'analyse num√©rique d'approximation d'√©quations diff√©rentielles. Cette m√©thode est utilis√©e ici pour r√©soudre l'√©quation diff√©rentielle associ√©e au mouvement d'un photon dans le potentiel gravitationnel de Schwarzschild.

## #22 : fonction rungekutta_obs

üîß **Param√®tre** : L, h, r, A, E.

üí° **R√¥le** : Cette fonction utilise la m√©thode de Runge-Kutta d'analyse num√©rique d'approximation d'√©quations diff√©rentielles. Cette m√©thode est utilis√©e ici pour r√©soudre l'√©quation diff√©rentielle associ√©e au mouvement d'un photon dans le potentiel gravitationnel de Schwarzschild dans le r√©f√©rentiel de l'observateur.

## #23 : fonction calcul_rmax 

üîß **Param√®tres** : L, E, vr, r0, rmax1ou2

üí° **R√¥le** : Cette fonction semble calculer le rayon maximale de l'orbite avec diverses conditions.

üìë **Fonctionnement simplifi√©**: Il semble il y a voir plusieurs cas de figures : 
1. Dans le cas o√π L<2*sqrt(3)*m on a rmax=r0.
2. Dans le cas o√π L <= 4*m et L>2*sqrt(3)*m on √† nouveau plusieurs cas de figure :<br>
üîπ Si Vr_mob(L,r0)<=Vr_mob(L,r1) et r0>r1 alors on a √† nouveau deux autres cas de figure : si r3 > r0 alors rmax=r3 et si r3 < r0 on a rmax=r0. <br>
üîπ Sinon rmax=r0.<br>
3. Dans le cas o√π L > 4*m on a rmax=r0.

üì∞ **Informations** : Cette fonction utilise la fonction **Vr_mob()**.

## #24 : fonction pausee

üîß **Param√®tres** : compteur, mobile, mobilefactor

üí° **R√¥le** : Cette fonction semble g√©rer le fonctionnement du bouton pause. Elle g√®re la mise en pause et la reprise de l'animation.

üìë **Fonctionnement** :
1. Dans le cas o√π l'animation n'est pas en pause avant qu'on appuie sur le bouton cela la met en pause. L'ic√¥ne du bouton de pause est chang√©e, le texte du bouton de pause est chang√© en "Reprendre", le message d'indication sur l'√©tat du calcul est mis √† jour pour montrer que le calcul est en pause et l'intervalle d'animation est effac√©.
2. Dans le cas o√π l'animation √©tait en pause avant que l'on appuie sur le bouton cela la remet en marche. L'ic√¥ne du bouton de pause est chang√©e, le texte du bouton de pause est chang√© en "Pause", le message d'indication du calcul est mis √† jour pour montrer qu'il est √† nouveau en cours et un nouvel intervalle d'animation est cr√©√©. 

## #25 : fonction clavierEvenement

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction permet √† l'utilisateur d'effectuer certaines actions de l'interface en utilisant les touches du clavier au lieu de la souris.

üìë **Fonctionnement** :
1. La fonction d√©tecte lorsque l'utilisateur presse une touche du clavier.
2. A chaque fois qu'une touche est press√©e elle v√©rifie quelle touche √† √©t√© press√©e.
3. Ensuite il y a plusieurs actions en fonction da la touche press√©e :<br>
üîπ Pour "z" : d√©clenche un clic sur l'√©v√©nement avec l'ID "r1". <br>
üîπ Pour "e" : d√©clenche un clic sur l'√©v√©nement avec l'ID "rebondd".<br>
üîπ Pour "q" : d√©clenche un clic sur l'√©v√©nement avec l'ID "start".<br>
üîπ Pour "s" : d√©clenche un clic sur l'√©v√©nement avec l'ID "clear".<br>
üîπ Pour "d" : d√©clenche un clic sur l'√©v√©nement avec l'ID "boutton_enregis".<br>
üîπ Pour "f" : d√©clenche un clic sur l'√©v√©nement avec l'ID "boutton_recup".<br>
üîπ Pour "w" : d√©clenche un clic sur l'√©v√©nement avec l'ID "moinsvite".<br>
üîπ Pour "x" : d√©clenche un clic sur l'√©v√©nement avec l'ID "pau".<br>
üîπ Pour "c" : d√©clenche un clic sur l'√©v√©nement avec l'ID "plusvi".<br>

## #26 : fonction rafraichir2

üîß **Param√®tres** : context, mobilefactor, rmaxjson, r0ou2, compteur

üí° **R√¥le** : Cette fonction est responsable de mettre √† jour certains √©l√©ments de l'interface grafique en fonction des arguments fournis.

üìë **Fonctionnement** :
1. Cette fonction commence par faire appel √† la fonction **majFondFixe()**.
2. Puis ensuite elle fait l'appel √† la fonction **creation_blocs(context, mobilefactor, rmaxjson, r0ou2, compteur)**.

üì∞ **Informations** : Cette fonction utilise les autres fonctions : **majFondFixe()** et **creation_blocs**.

## #27 : fonction rafraichir

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction a pour r√¥le de rafraichir la page en rechargeant compl√®tement son contenu et en r√©initialisant le mode √† "observateur distant" et en elevant le rebond.

üìë **Fonctionnement** :
1. Tout d'abord la fonction recharge la page actuelle.
2. Puis elle met le mode √† "observateur distant".
3. Le bouton "Rebond" n'est plus press√©.

## #28 : fonction enregistrer

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction a pour r√¥le d'enregistrer une image de la trajectoire d'un photon dans la m√©trique de Scwharzschild. 

üìë **Fonctionnement** :
1. Elle commence par v√©rifier si une trajectoire a bien √©t√© trac√©e et si c'est le cas : <br>
üîπ Elle copie le contenu du canvas principal 'canvas' sur un autre canvas 'canvas3'. <br>
üîπ Elle utilise la fonction **canvasToImage(canvas3, {name: 'Trajectoire_photon_Schwar', type: 'png'})** pour enregistrer le canvas3 sous forme d'image PNG avec un nom sp√©cifi√© 'Trajectoire_photon_Schwar'.<br>
üîπ Elle appelle une fonction **majFondFixe3()** pour s√ªrement mettre √† jour un √©l√©ment.<br>
2. Dans le cas contraire elle affiche une alerte avec un message r√©cup√©r√© √† partir de **o_recupereJson()** qui est **texte.pages_trajectoire.message_enregistrer**.

üì∞ **Informations** : Cette fonction utilise les autres fonctions : **canvasToImage()** qui vient de **canvas-to-image.js**, **majFondFixe3()** et **o_recupereJson()**.

## #29 : fonction siTrajectoireSimple

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction g√®re des actions √† effectuer si le type de la trajectoire est d√©fini comme "simple".

üìë **Fonctionnement** :
1. La fonction commence par v√©rifier si la valeur de l'√©l√©ment d'ID "element" est √©gal √† 'simple' et si c'est le cas elle fait plusieurs choses.
2. Dans ce cas elle commence par appeler la fonction **majFondFixe()**.
3. Ensuite elle appelle la fonction **creation_blocs(context)**.
4. Puis elle multiplie par 2 le diam√®tre de la particule.

üì∞ **Informations** : Cette fonction utilise les autres fonctions **majFondFixe()** et **creation_blocs()**.

## #30 : fonction traceEstAbsent

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction indique que la trajectoire n'a pas √©t√© trac√©e.

üìë **Fonctionnement** : Elle affecte la valeur "0" √† l'√©l√©ment avec l'ID "trace_present".

## #31 : fonction siTrajectoireComplete

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction g√®re des actions √† effectuer si le type de la trajectoire est d√©fini comme "complete".

üìë **Fonctionnement** : Si l'√©l√©ment avec l'ID "element" est √©gal √† 'complete' alors le diametre de la particule "diametre_particule" prend la valeur "DIAMETRE_PART" qui est une des variables globales d√©finit au d√©but du fichier.

## #32 : fonction choixTrajectoire

üöß *Cette fonction regroupe juste les fonctions **siTrajectoireComplete()** et une version l√©g√®rement diff√©rente se **siTrajectoireSimple()**.*

üîß **Param√®tres** : compteur, context, mobile, mobilefactor, rmaxjson, r0ou2

üí° **R√¥le** : Cette fonction g√®re le choix entre deux type de trajectoires : soit une trajectoire "simple" soit une trajectoire compl√®te ("complete").

üìë **Fonctionnement** :
1. Si l'√©l√©ment d'ID "element" a la valeur 'simple' alors : <br>
üîπ La fonction **majFondFixe()** est appell√©e. <br>
üîπ La fonction **creation_blocs(context, mobilefactor, rmaxjson, r0ou2, compteur)** est appel√©e. <br>
üîπ Le diam√®tre de la particule (diametre_particule) est doubl√© de sa valeur initiale (DIAMETRE_PART).<br>
2. Si l'√©l√©ment d'ID "element" a la valeur 'complete' :
üîπ Le diam√®tre de la particule (diametre_particule) garde sa valeur initiale (DIAMETRE_PART).<br>

üì∞ **Informations** : Cette fonction utilise les autres fonctions : **majFondFixe()** et **creation_blocs()**.

## #33 : fonction estUnMobile

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction est utilis√©e pour d√©terminer si l'utilisateur acc√®de √† COSMOGRAVITY depuis un t√©l√©phone portable ou non et ce en v√©rifiant la largeur maximale de la fen√™tre.

üìë **Fonctionnement** :
1. Cette fonction stocke dans une variable x une requ√™te pour une fen√™tre avec une largeur maximale de 960 pixels.
2. Si la requ√™te correspondante est vraie alors elle cache le bouton ayant l'ID "bouton_info".
3. Si le requ√™te correspondante n'est pas vrai alors elle rend le bouton ayant l'ID "bouton_info" visible.

## #34 : fonction commandes

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction sert √† afficher une alerte sp√©cifique associ√©e au texte **texte.pages_trajectoire.commandes_horsSchwarMassif** que l'on doit r√©cup√©rer √† l'aide de la fonction **o_recupereJson()**.

üì∞ **Informations** : Cette fonction utilise une autre fonction **o_recupereJson()**.

## #35 : fonction majFondFixe

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction est utilis√©e pour mettre √† jour et afficher des informations contextuelles sur le canvas utilis√© dans COSMOGRAVITY.

üìë **Fonctionnement**:
1. Cette fonction commence par effacer le contenu du canvas.
2. Elle remplit ensuite le canvas avec une couleur de fond blanc.
3. Elle utilise diff√©rentes tailles de police et couleurs pour afficher des textes sp√©cifiques sur le canvas : **texte.page_trajectoire_photon.titre**, **texte.page_trajectoire.entrees**. 
4. Elle affiche les informations actuelles du syst√®me : le rayon physique de l'astre r et la masse de l'astre M. 
5. Elle v√©rifie la valeur du bouton d'ID "boutton_ammorti" et si elle est √©gale √† 1 elle affiche le texte **texte.page_trajectoire_massive.amortissement**.
6. Elle v√©rifie la valeur de l'√©l√©ment d'ID "traject_type2" et si elle est √©gale √† "observateur" elle affiche **texte.pages_trajectoire.observateur** et sinon elle affiche **texte.pages_trajectoire.photon**.
7. Elle affiche des informations sp√©cifiques aux mobiles/fus√©es comme la distance initiale du projectile au centre de l'astre, la vitesse tangentielle et la vitesse radiale.

## #36 : fonction majFondFixe44

üîß **Param√®tres** : mobile

üí° **R√¥le** : Cette fonction sert √† effacer le contenu du canvas associ√© √† un mobile sp√©cifique.

## #37 : fonction majFondFixe22

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction sert √† effacer le contenu du canvas associ√© au contexte graphique "context22".

## #38 : fonction majFondFixe3

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction sert √† effacer le contenu du canvas associ√© au contexte graphique "context3".

## #39 : fonction test_inte

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction sert √† v√©rifier la validit√© des param√®tres fournis avant de lancer la simulation.

üìë **Fonctionnement** : Voici les diff√©rentes v√©rifications qui sont effectu√©es : <br>
üîπ Si le rayon physique de l'astre est n√©gatif ou que la distance initiale du projectile au centre de l'astre est n√©gative alors une alerte s'affiche avec le texte **texte.pages_trajectoire.rayon_neg**. <br>
üîπ Si le rayon physique de l'astre est plus petit ou √©gal au rayon de Schwarzschild et qu'il est diff√©rent de 0 alors une alerte s'affiche avec le texte **texte.pages_trajectoire.rayonPhyInfHorz**.<br>
üîπ Si la distance initiale du projectile au centre de l'astre est plus petite ou √©gale au rayon de Scwharzschild alors une alerte s'affiche avec le texte **texte.pages_trajectoire.rayonHorzInfRayonSchw**.<br>
üîπ Si la distance initiale du projectile au centre de l'astre est plus petite au rayon physique de l'astre alors une alerte s'affiche avec le texte **texte.pages_trajectoire.lancerInterdit**.<br>
üîπ Si la vitesse radiale et la vitesse tangentielle sont nulles alors une alerte s'affiche avec le texte **texte.pages_trajectoire.vitesses_initiales_nulles**.<br>

üì∞ **Informations** : Cette fonction utilise une autre fonction **o_recupereJson()**.

## #40 : fonction creation_blocs

üîß **Param√®tres** : context, mobilefactor, rmaxjson, r0ou2, compteur

üí° **R√¥le** : Cette fonction a pour r√¥le le trac√© visuel de diff√©rents √©l√©ments graphique li√©s au rayon de Schwarzschild et aux dimensions du canvas.

üìë **Fonctionnement** :
1. Cette fonction dessine un cercle repr√©sentant le rayon de Schwarzschild avec diff√©rentes configurations en fonction de si factGlobalAvecClef * m / rmaxjson[cle]) < 3.
2. Elle dessine √©ventuellement une zone color√©e pour repr√©senter le rayon physique de l'astre si m < r_phy (le rayon physique de l'astre).
3. Elle ajouter des √©tiquettes et des lignes pour indiquer les dimensions et l'√©chelle sur le canvas. 

üì∞ **Informations** : Cette fonction utilise les couleurs pr√©difinies **COULEUR_RS** et **COULEUR_PHY**.

## #41 : fonction canvasAvantLancement

üöß *Les deux premiers for peuvent √™tre r√©unis en un seul.*

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction a pour r√¥le la configuration et la pr√©paration du canvas (avec la mise √† l'√©chelle) avant le lancement de la simulation.

üìë **Fonctionnement simplifi√©** :
1. Cette fonction commence par calculer les facteurs de mise √† l'√©chelle pour chacun des mobiles en fonction du rapport de la distance initiale du mobile au centre de l'astre par rapport au rayon maximal entre tous les mobiles. Ce sont ces facteurs de mise √† √©chelle qui sont stock√©s dans le tableau "facteurDeMalheur."
2. Elle choisit le facteur de mise √† l'√©chelle global √† utiliser en se basant sur la fus√©e avec la distance initiale au centre de l'astre la plus grande. 
3. Elle r√©cup√®re le canvas et le contexte et les initialise pour le dessin en d√©finissant le style de la ligne et en effa√ßant tout dessin pr√©c√©dent.
4. Elle affiche le texte indiquant l'√©chelle actuelle sur le canvas, puis dessine une barre d'√©chelle pour illustrer visuellement cette √©chelle.

## #42 : fonction boutonAvantLancement

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction g√©re l'affichage et le fonctionnement des boutons et des panneaux avant le lanchement de la simulation.

üìë **Fonctionnement** : 
1. Cette fonction commence par cacher l'√©l√©ment d'ID "panneau_mobile" qui semble √™tre pour l'acc√©l√©ration et la d√©cc√©l√©ration de la simulation.
2. Puis elle cache l'√©l√©ment d'ID "panneau_mobile2" qui semble √™tre pour les zoom.
3. Si le bouton pour zoomer est cliqu√© la fonction **foncPourZoomMoinsAvantLancement()** est appel√©e.
4. Si le bouton pour d√©zoomer est cliqu√© la fonction **foncPourZoomPlusAvantLancement()** est appel√©e.
5. Si le bouton pour aller plus vite est cliqu√© la fonction **foncPourVitAvantLancement()** est appel√©e et la propri√©t√© "myParam" de l'√©l√©ment avec l'ID "plusvite" est mise √† la valeur true.
6. Si le bouton pour aller plus vite est cliqu√© la fonction **foncPourVitAvantLancement()** est appel√©e et la propri√©t√© "myParam" de l'√©l√©ment avec l'ID "moinsvite" est mise √† la valeur false.

üì∞ **Informations** : Cette fonction utilise les autres fonctions **foncPourZoomMoinsAvantLancement()**, **foncPourZoomPlusAvantLancement()** et **foncPourVitAvantLancement()**.

## #43 : fonction foncPourZoomPlusAvantLancement

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction permet d'augmenter progressivement le facteur de zoom du canvas lorsque l'utilisateur clique sur le bouton pour zoomer. Elle met aussi √† jour l'affichage de la valeur du zoom (le nombre de fois o√π on a cliqu√© sur le zoom).

üìë **Fonctionnement** : Le facteur de zoom augmente de 20% √† chaque clic sur le bouton zoom et la fonction **canvasAvantLancement()** est appel√©e pour mettre √† jour le canvas en fonction. Et chaque fois que le bouton de zoom est cliqu√© la valeur de nz est incr√©ment√©e de +1.

üì∞ **Informations**: Cette fonction utilise l'autre fonction **canvasAvantLancement()**.

## #44 : fonction foncPourZoomMoinsAvantLancement

üîß **Param√®tres** : N/A

üí° **R√¥le** : Cette fonction permet de r√©duire progressivement le facteur de zoom du canvas lorsque l'utilisateur clique sur le bouton pour d√©zoomer. Elle met aussi √† jour l'affichage de la valeur du zoom (le nombre de fois o√π on a cliqu√© sur le d√©zoom).

üìë **Fonctionnement** : Le facteur de zoom diminue de 20% √† chaque clic sur le bouton zoom et la fonction **canvasAvantLancement()** est appel√©e pour mettre √† jour le canvas en fonction. Et chaque fois que le bouton de d√©zoom est cliqu√© la valeur de nz est incr√©ment√©e de -1.

üì∞ **Informations**: Cette fonction utilise l'autre fonction **canvasAvantLancement()**.

## #45 : fonction foncPourVitAvantLancement

üîß **Param√®tres** : accelerer

üí° **R√¥le** : Cette fonction permet √† l'utilisateur d'ajuster la vitesse de la simulation avant son lancement en cliquant sur les boutons d'acc√©l√©ration et d√©c√©l√©ration. Elle met aussi √† jour l'affichage de la vitesse.

üìë **Fonctionnement** : 
1. En fonction de si l'utilisateur a cliqu√© sur le bouton pour acc√©l√©rer ou ralentir elle fait diff√©rentes choses.
2. Si l'utilisateur a cliqu√© sur le bouton pour acc√©l√©rer alors la valeur de compteurVitesseAvantLancement est incr√©ment√©e de 1.
3. Si l'utilisateur √† cliqu√© sur le bouton pour ralentir alors la valeur de compteurVitesseAvantLancement est d√©cr√©ment√©e de 1.
4. La valeur affich√©e de ns est mise √† jour pour refl√©ter la nouvelle valeur de la vitesse.

## #46 : fonction MAJGraphePotentiel

üîß **Param√®tres** : data1, data2, compteur, mobile

üí° **R√¥le** : Cette fonction met √† jour les donn√©es du graphique de potentiel en fonction des nouvelles valeurs calcul√©es pour "data1" puis met √† jour le graphique en lui-m√™me.

üìë **Fonctionnement** :
1. Cette fonction commence par r√©initialiser le tableau data1 √† une liste vide.
2. Puis pour une valeur de r entre 0.7 fois celui de la particule et 1.3 fois celui de la particule avec un pas de "mobile.dr" la valeur du potentiel V est calcul√©e. Pour calculer la valeur du potentiel la fonction **Vr_mob(r, mobile.E, mobile.L)** √† laquelle on soustrait 1 est utilis√©e.
3. Chaque nouvelle valeur du potentielle est ainsi ajout√©e comme un objet contenant la paire '(r,V)' √† la liste "data1".
4. Puis pour finir une fonction **graphique_creation_pot(0,data1,data2,compteur,mobile)** est appel√©e. 

üì∞ **Informations** : Cette fonction utilise l'autre fonction **Vr_mob()**.


